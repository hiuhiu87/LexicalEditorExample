import { LexicalEditor, LexicalNodeReplacement } from "lexical";
import { EditorConfig } from "lexical/LexicalEditor";
import React, { ElementType } from "react";
import { BeautifulMentionComponentProps } from "./BeautifulMentionsPluginProps";
import { SerializedBeautifulMentionNode } from "./MentionNode";
export type CustomBeautifulMentionNodeClass = ReturnType<typeof generateClass>;
export declare let CustomBeautifulMentionNode: CustomBeautifulMentionNodeClass;
/**
 * Instead of using the default `BeautifulMentionNode` class, you can
 * extend it and use the mention component of your choice.
 */
export declare function createBeautifulMentionNode(mentionComponent: ElementType<BeautifulMentionComponentProps>): [CustomBeautifulMentionNodeClass, LexicalNodeReplacement];
declare function generateClass(mentionComponent: ElementType<BeautifulMentionComponentProps>): {
    new (trigger: string, value: string, data?: {
        [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
    } | undefined, key?: string | undefined): {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: string | undefined): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: (() => import("lexical").DOMConversionMap<any> | null) | undefined;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").BaseSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    getType(): string;
    clone(node: {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: string | undefined): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: (() => import("lexical").DOMConversionMap<any> | null) | undefined;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").BaseSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    }): {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: string | undefined): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: (() => import("lexical").DOMConversionMap<any> | null) | undefined;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").BaseSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importJSON(serializedNode: SerializedBeautifulMentionNode): {
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        createDOM(): HTMLElement;
        updateDOM(): boolean;
        exportDOM(): import("lexical").DOMExportOutput;
        getTextContent(): string;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        getCssClassesFromTheme(config: EditorConfig): {
            className: string | undefined;
            classNameFocused: string | undefined;
            classNames: import("./theme").BeautifulMentionsCssClassNames | undefined;
        };
        constructor: import("lexical").KlassConstructor<{
            new (key?: string | undefined): import("lexical").DecoratorNode<React.JSX.Element>;
            getType(): string;
            clone(_data: unknown): import("lexical").LexicalNode;
            importDOM?: (() => import("lexical").DOMConversionMap<any> | null) | undefined;
            importJSON(_serializedNode: import("lexical").SerializedLexicalNode): import("lexical").LexicalNode;
            transform(): ((node: import("lexical").LexicalNode) => void) | null;
        }>;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").BaseSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectStart(): import("lexical").RangeSelection;
        selectEnd(): import("lexical").RangeSelection;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importDOM(): import("lexical").DOMConversionMap | null;
    transform(): ((node: import("lexical").LexicalNode) => void) | null;
};
export {};
